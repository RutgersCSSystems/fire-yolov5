
# Lib Predictor README
This library is designed to deduce per file descriptor access patterns and prefetch based on it.

It uses LD_PRELOAD to attach to the binary at runtime and injects the library code to the 
following commands in the app : fopen, fread, fwrite, open, read, write, fclose, close, pread
look at frontend.cpp



## About the access pattern detection:

The library keeps a HISTORY of read accesses for each file descriptor.
When the length of past accesses > HISTORY, it goes over this history and determines if 
the accesses are sequential, strided or Random. Since program access patterns change over time,
we have a per file descriptor likelyness that the access is seq, strided or Random.

DEFNSEQ < LIKELYNSEQ < POSSNSEQ < MAYBESEQ < POSSSEQ < LIKELYSEQ < DEFSEQ


### Q1. How does it know if the app is seq or strided ?

```
 -------------|=========-----------|==========---------------
            Pos1, BytesRead       Pos2, BytesRead
```

The above is a representation of a file stream; PosX a the start of a read operation from the app.

The app is considered to be doing a sequential read if Pos2 - (Pos1 + BytesRead) <= PAGE_SIZE.
which means the distance between the last byte read and the next read is within the same page.

This is because readaheads/fadvice/prefetches inside the OS work at page granualarity.

If the nr of instances of sequential reads in a particular history range is more than half the history, the likeliness that this file is being read sequentially is increased.


Based on the likeliness, the app's readahead window is increased. look at update_stride
______________________________________________________________________

### Q2. How does the library know when to prefetch ?

At each read, the libray does the following
1. Insert the new read position and bytes.
2. Update the stride based on the new read
3. Checks if there is a need to prefetch or the read is likely seq.
4. If yes - Prefetch

It checks if there is a need to prefetch by storing the previously fetched position. This is assuming that all the readahead calls are fulfilled by the OS which may not be true.

function: insert_prefetch_pos
_______________________________________________________________________

### Q3. What about strided reads ?

Ans: There may be workloads that take huge steps between their reads: ie, their Pos2 - (Pos1 + BytesRead) can be > PAGE_SIZE. 
Currently, their SeqLikelyness is reduced which may not be the case.
_______________________________________________________________________

### Q4. How does this library do a better job than the OS ?


Ans: To answer this question, it is imperetive to first understand how prefetching works in the OS.

Look at ondemand_readahead in linux


1. Given a read syscall, it checks the previous reads on the file
2. It checks the last 16 pages to see if there were seq/small strided reads on the file
3. If that is true, it fetches more pages than requested, else it fetches exact pages



It seems like the library and the OS have similar ways of finding access patterns. Need to investigate more.
_______________________________________________________________________

## Usage Info

### Q1. Compilation and Installation
To Compile `make -j8; make install`

### Q2. Types of shared libs and their usage

There are multiple preloadable files generated by the predictor library
1. libnopred.so : Switches off all the predictors.
2. libonlyospred.so : Switches off all the predictors, switch on only OS predictors
3. libonlyapppred.so : Switches off OS and Lib predictor, let app prefetch if it does
4. libonlylibpred.so : Only Lib predictor runs.
5. libos_apppred.so : OS and App predictors run
6. libos_libpred.so : OS and Lib predictors run
7. libcrosslayer.so : All predictors are switched on
8. libjuststats.so : Does not change any behaviour; just adds syscalls for linux global stats
9. libonlyinterecpting.so: Just intercepts the calls and delivers them to the OS. No extra work

To use any of the above `LD_PRELOAD=/usr/lib/libname.so <APP> <APP_FLAGS>`

Alternatively one could do : 
```
export LD_PRELOAD="/usr/lib/libname.so"
<APP> <APP_FLAGS>
export LD_PRELOAD=""
```
### Q3. Compile Time Flags and their Meanings:
1. DEBUGFLAGS : Enables all the debugging printing `debug_print();`
2. NOBGTHREADS : disables background prefetching workers `thpool_init()`
3. DELAYPRFETCH : delays prefetching, based on the extend of previous readaheads. If previous readahead covers what would be prefetched in this instant, it would be skipped.
4. PINCORES : Pin all the threads to different cores in the system assuming the system has enough cores. **NOT WORKING RIGHT NOW**
5. CROSSLAYER : Enables file prefetch stats in custom linux 5.14. Not working for threads
6. DISABLEAPPPRED : Disables app prefetching and any fadvice.
7. DISABLEOSPRED : Disables OS prefetching
8. DISABLE_FADV_RANDOM : Disables any FADV_RANDOM from App
9. PREDICTOR & SEQUENTIAL : Enables library prefetching when used together. 
10. ENABLE_GLOBAL_CACHE_STATS : Enables global stats for cache hits/misses in modified linux 5.14
11. READ_RA : Enables read_ra syscall instead of read and readahead for the read/fread/pread calls intercepted
12. DISABLE_INTERCEPTING : Disables any form of function intercepting from the library. Will only run constructor and destructor

### Q4. Are there any dependencies for Compile time flags?
1. Cannot use READ_RA with BGTHREADS: Do not disable NOBGTHREADS while enabling READ_RA. It wouldn't work.
2. Do not DISABLE_INTERCEPTING if you want to run anything other than constructor and destructor. Note: constructors and destructors are not called for threads spawned using clone syscall.
