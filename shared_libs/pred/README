This library is designed to deduce per file descriptor access patterns and prefetch based on it.

It uses LD_PRELOAD to attach to the binary at runtime and injects the library code to the 
following commands in the app : fopen, fread, fwrite, open, read, write, fclose, close, pread
look at frontend.cpp



About the access pattern detection:

The library keeps a HISTORY of read accesses for each file descriptor.
When the length of past accesses > HISTORY, it goes over this history and determines if 
the accesses are sequential, strided or Random. Since program access patterns change over time,
we have a per file descriptor likelyness that the access is seq, strided or Random.

DEFNSEQ < LIKELYNSEQ < POSSNSEQ < MAYBESEQ < POSSSEQ < LIKELYSEQ < DEFSEQ


Q1. How does it know if the app is seq or strided ?


-------------|=========-----------|==========---------------
            Pos1, BytesRead       Pos2, BytesRead

The above is a representation of a file stream; PosX a the start of a read operation from the app.

The app is considered to be doing a sequential read if Pos2 - (Pos1 + BytesRead) <= PAGE_SIZE.
which means the distance between the last byte read and the next read is within the same page.

This is because readaheads/fadvice/prefetches inside the OS work at page granualarity.

If the nr of instances of sequential reads in a particular history range is more than half the history, the likeliness that this file is being read sequentially is increased.


Based on the likeliness, the app's readahead window is increased. look at update_stride
______________________________________________________________________

Q2. How does the library know when to prefetch ?

At each read, the libray does the following
1. Insert the new read position and bytes.
2. Update the stride based on the new read
3. Checks if there is a need to prefetch or the read is likely seq.
4. If yes - Prefetch

It checks if there is a need to prefetch by storing the previously fetched position. This is assuming that all the readahead calls are fulfilled by the OS which may not be true.

function: insert_prefetch_pos
_______________________________________________________________________

Q3. What about strided reads ?

Ans: There may be workloads that take huge steps between their reads: ie, their Pos2 - (Pos1 + BytesRead) can be > PAGE_SIZE. 
Currently, their SeqLikelyness is reduced which may not be the case.
_______________________________________________________________________

Q4. How does this library do a better job than the OS ?


Ans: To answer this question, it is imperetive to first understand how prefetching works in the OS.

Look at ondemand_readahead in linux


1. Given a read syscall, it checks the previous reads on the file
2. It checks the last 16 pages to see if there were seq/small strided reads on the file
3. If that is true, it fetches more pages than requested, else it fetches exact pages



It seems like the library and the OS have similar ways of finding access patterns. Need to investigate more.
_______________________________________________________________________
