#! /usr/bin/env python


#import zplot
from zplot import *


import sys, getopt


def main(argv):

	inputfile = ''
	outputfile = ''
	ymax=3000
	yint=400
	xfield='ops'
	xlegend='DevFS techniques'
	barwidth = 0.9
	xfontsize=12.0
        yfontsize=12.0
	xydim=[210, 210]
	xystart=[180,170]
	xylegend=[60,200]
	xfont = xfontsize
	yfont = yfontsize
	xycord = [50,20]
	#barwidth = 0.3

	try:
		opts, args = getopt.getopt(argv,"hi:o:y:r:",["ifile=","ofile=","ymax=","yint="])
	except getopt.GetoptError:
		print 'XX.py -i <inputfile> -o <outputfile>'
		sys.exit(2)

	for opt, arg in opts:
		if opt == '-h':
			 print 'verticalbars.py -i <inputfile> -o <outputfile>'
			 sys.exit()
		elif opt in ("-i", "--ifile"):
			 inputfile = arg
		elif opt in ("-o", "--ofile"):
			 outputfile = arg
		elif opt in ("-y", "--ymax"):
			 ymax = int(arg)
			 print ymax
		elif opt in ("-r", "--intrvl"):
			 yint = int(arg)
			 print yint


	print 'Input file is', inputfile
	print 'Output file is', outputfile

	# populate zplot table from data file
	t = table(inputfile)
	print t


	# create the postscript file we'll use as our canvas
	ctype = 'pdf'
	c1 = canvas(ctype, title=outputfile, dimensions=xydim)

	# on the x-axis, we want categories, not numbers.  Thus, we
	# determine the number of categories by checking the max
	# "rownumber" (a field automatically added by zplot).  We want a
	# half bar width (0.5) to the left and right of the bar locations
	# so we don't overflow the drawable.
	d = drawable(c1,  coord=xycord, xrange=[-0.5,t.getmax('rownumber')+1],
                yrange=[0,ymax], dimensions=xystart)

	# xmanual is a list of the form [(label1,x1), (label2,x2), ...].
	# We want to use the "op" field from the data file as our labels
	# and use "rownumber" as our x coordinate.
	axis(drawable=d, style='xy',
                xmanual=[['RocksDB',0],['filebench',1],['Redis',2]], 
	     xlabelrotate=0,
	     yauto=[0,ymax,yint],
	     ytitle='Memory Pages (in 100K)', ylabelfontsize=yfont, xlabelfontsize=xfont,	
	     linewidth=0.5, ytitleshift	= [0,0],
	     ytitlesize = yfont, xtitlesize = xfont)

	# we are going to create several bars with similar arguments.  One
	# easy way to do this is to put all the arguments in a dict, and
	# use Python's special syntax ("**") for using the dict as named
	# args.  Then we can tweak the args between each call to
	# verticalbars.
	#
	# yfield determines the bar height, and stackfields determines
	# where the bottom of a bar starts.  This is useful for showing
	# several bar sections to indicate a breakdown.  After the first
	# bar, we append the previous yfield to stackfields to stack the bars.
	p = plotter()
	L = legend()
	barargs = {'drawable':d, 'table':t, 'xfield':'rownumber',
		   'linewidth':0, 'fill':True, 'barwidth':barwidth,
		   'legend':L, 'stackfields':[]}

	# randread bar
	barargs['yfield'] = 'Cache'
	barargs['legendtext'] = 'Cache Pages'
	barargs['fillcolor'] = 'darkgray'
	p.verticalbars(**barargs)

	# storage bar
	barargs['stackfields'].append(barargs['yfield'])
	barargs['yfield'] = 'Migrated'
	barargs['legendtext'] = 'Migrated Cache Pages'
	barargs['fillcolor'] = 'lightgrey'
	p.verticalbars(**barargs)

	barargs['stackfields'].append(barargs['yfield'])
	barargs['yfield'] = 'Apppages'
	barargs['legendtext'] = 'App Pages'
	barargs['fillcolor'] = 'black'
	p.verticalbars(**barargs)

	# we want legend entries to be all on one line.  Thus, we use
	# skipnext=1 to get one row.  We specify the horizontal space
	# between legend symbols (not considering text) with skipspace.
        L.draw(c1, coord=xylegend, skipspace=50,  skipnext=5, fontsize=xfont)
	  
	c1.render()


if __name__ == "__main__":
   main(sys.argv[1:])

