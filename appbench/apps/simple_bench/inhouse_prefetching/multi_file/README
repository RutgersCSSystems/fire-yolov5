It has been observed (using lock_stat) that when multiple worker threads try to readahead
from a single shared file to improve prefetching performance, it increases the total
read time from the main thread primarily due to locking contention on xarray etc.


This simple benchmark will test this hypothesis.

it will do so by dividing the big shared file into small private files(=NR_WORKERS)
main thread would read from a given file based on the offset.


Compile time Flags in read.c
FILESZ : size of file in GB
NR_RA_PAGES : Number of pages to be readahead in each request
NR_BG_THREADS : Number of background worker prefetching threads
ONLYAPP : Disables OS internal prefetching (FADV_RANDOM)
PREFETCH : Enables Application level prefetching
DONT_READ_FILE : Disables the main reader thread


Compile time Flags in Makefile
SIZE : total desired filesize
NR_RA_PG : desired size of each readahead request
NR_BG_THREADS : desired number of bg worker prefetching threads


#######
Example Use:

```
make SIZE=20 NR_RA_PG=1280 NR_BG_THREADS=8
```

This will compile the benchmark to use multiple files totalling 20GB, will readahead 1280 pages in each req 
and will have 8 BG threads to readahead in addition to the main thread which does reads.
Since there are 8 bg threads here, each pvt file would be 20/8 GB.


## List of binaries compiled

read_onlyospfetch - Disables app level prefetching. OS prefetching is enabled while reading
read_noprefetch - Disables os and  app level prefetching while reading.
read_onlypfetch - Disables OS prefetching. Only runs app level prefetcher threads while reading.
read_os_smallpfetch - OS prefetching enabled, app prefetcher threads use NR_RA_PG sized requests for each readahead
read_os_fullpfetch - OS prefetching enabled, app prefetcher threads prefetch complete file in one readahead
dont_read_os_pfetch - OS prefetching enabled, app prefetcher enabled, main reader thread is disabled
